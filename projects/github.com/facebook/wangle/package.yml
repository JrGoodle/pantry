distributable:
   url: https://github.com/facebook/wangle/archive/refs/tags/v{{version.raw}}.tar.gz
   strip-components: 1

versions:
  github: facebook/wangle
  strip: /v/

dependencies:
  boost.org: '*'
  google.com/double-conversion: ^3
  github.com/facebookincubator/fizz: '*'
  fmt.dev: ^9
  facebook.com/folly: '*'
  gflags.github.io: '*'
  google.com/glog: '*'
  libevent.org: '*'
  libsodium.org: '*'
  lz4.org: ^1
  openssl.org: ^1.1
  google.github.io/snappy: '*'
  facebook.com/zstd: ^1
  darwin:
    sourceware.org/bzip2: '*'
    zlib.net: '*'

build:
  dependencies:
    tea.xyz/gx/cc: c99
    tea.xyz/gx/make: '*'
    cmake.org: ^3
  working-directory: wangle
  script: |
    cmake . -DBUILD_SHARED_LIBS=ON $ARGS
    make install

    make clean

    cmake . -DBUILD_SHARED_LIBS=OFF $ARGS
    make

    # lib.install "lib/libwangle.a"

    # pkgshare.install Dir["example/echo/*.cpp"]
  env:
    ARGS:
      - -DCMAKE_INSTALL_PREFIX={{prefix}}
      - -DCMAKE_BUILD_TYPE=Release
      - -DBUILD_TESTS=OFF

provides:
  - bin/wangle

test:
  dependencies:
    tea.xyz/gx/cc: c99
  script: |
    # cxx_flags = %W[
    #   -std=c++17
    #   -I#{include}
    #   -I#{Formula["openssl@1.1"].opt_include}
    #   -L#{Formula["gflags"].opt_lib}
    #   -L#{Formula["glog"].opt_lib}
    #   -L#{Formula["folly"].opt_lib}
    #   -L#{Formula["fizz"].opt_lib}
    #   -L#{lib}
    #   -lgflags
    #   -lglog
    #   -lfolly
    #   -lfizz
    #   -lwangle
    # ]
    # if OS.linux?
    #   cxx_flags << "-L#{Formula["boost"].opt_lib}"
    #   cxx_flags << "-lboost_context-mt"
    #   cxx_flags << "-ldl"
    #   cxx_flags << "-lpthread"
    # end

    # system ENV.cxx, pkgshare/"EchoClient.cpp", *cxx_flags, "-o", "EchoClient"
    # system ENV.cxx, pkgshare/"EchoServer.cpp", *cxx_flags, "-o", "EchoServer"

    # port = free_port
    # fork { exec testpath/"EchoServer", "-port", port.to_s }
    # sleep 10

    # require "pty"
    # output = ""
    # PTY.spawn(testpath/"EchoClient", "-port", port.to_s) do |r, w, pid|
    #   w.write "Hello from Homebrew!\nAnother test line.\n"
    #   sleep 20
    #   Process.kill "TERM", pid
    #   begin
    #     r.each_line { |line| output += line }
    #   rescue Errno::EIO
    #     # GNU/Linux raises EIO when read is done on closed pty
    #   end
    # end
    # assert_match("Hello from Homebrew!", output)
    # assert_match("Another test line.", output)
